the distinction between temp.md and CLAUDE.md has more or less fallen apart. here's my idea for a new documentation structure
> **üìù Purpose**: 
> - Document upcoming tasks and discussions needed to specify them
>
> **See also**:
> - README.md:
>   - User-facing documentation
>     - material that can go in app help or about screen
>     - philosophy, current architecture, etc.
>     - features
>   - developer documentation
> - **PROGRESS.md** - Completed work (for reporting)
> - **TESTING.md** - Testing philosophy and practices

TODO:
- move everything out of temp.md
    - if it's an upcoming task, put it here
    - if it's completed, put it in PROGRESS.md
    - if it should be seen by users or developers, put it in README.md
- maybe treat specific tasks and overall goals or features differently
  - but don't redundantly list the same thing in features and in tasks
  - if it's existing features, README
  - if it's upcoming features, here
- tasks related to specific features should be listed with those features
- try to keep tasks in planned implementation order
- for tasks/features dependent on upcoming discussions or open questions, list
  them with the discussion/question descriptions
- when questions are resolved, tasks can be separated from them and listed
  with other tasks
- try to remove redundancy
- once documentation is refactored, it should be clearer to me where
  i should put new tasks... now i forget the tasks i wanted to add that
  prompted me to want documentation refactoring in the first place

---

## Future Features

[moved from README.md]
- **Search & filter**: Full-text search, faceted filters, quick navigation
- **Custom presets**: Save frequently-used panel configurations
- **Neighborhood exploration**: Show k-hop neighbors, relationship type filters
- **Advanced views**: Network graphs, enum-class matrix, comparison views



### Architecture: Generalize Hierarchical Structure

**Current limitation**: `ClassNode` has `children: ClassNode[]` - hierarchy is type-specific.

**Problem**:
- Only classes can be hierarchical
- Can't reorganize views (e.g., show enums with classes nested under them)
- Variables are grouped by class but not using a general hierarchy abstraction
- Difficult to support alternate view modes

**Proposed solution**: Generic tree/hierarchy types
```typescript
// Generic tree node
interface TreeNode<T> {
  data: T;
  children: TreeNode<T>[];
  parent?: TreeNode<T>;
}

// Heterogeneous trees (ClassElement with EnumElement children)
interface HierarchyNode {
  element: Element;
  children: HierarchyNode[];
}

// Tree utilities
class Hierarchy<T> {
  roots: TreeNode<T>[];
  flatten(): T[]
  findByName(name: string): TreeNode<T> | null
}
```

**Benefits**:
- Any element type can be hierarchical
- Flexible view reorganization (classes under enums, enums under classes, etc.)
- Reusable tree operations (flatten, search, traverse)
- Could support DAGs later if needed (e.g., multiple inheritance)

**Implications**:
- Would replace `ClassNode.children` with more general structure
- Collections could support multiple hierarchy views
- Panel sections could render any hierarchy type
- Tests would need updating (currently assume ClassNode hierarchy)

### Phase 4: Search and Filter
- Search bar with full-text search across all elements
- Filter controls (checkboxes for class families, variable count slider)
- Highlight search results in tree/sections
- Quick navigation: search results open in new dialogs

### Phase 5: Neighborhood Zoom
- "Focus mode" showing only k-hop neighborhood around selected element
- Relationship type filters ("show only `is_a` relationships" vs "show associations")
- Breadcrumb trail showing navigation path
- "Reset to full view" button

### Enhanced Element Metadata Display
Show additional relationship counts for classes in tree view:
- **Current**: Only variable count shown (e.g., "Condition (20)")
- **Desired**: Show counts for associated enums, slots, and classes
- **Example**: "Condition (20 vars, 5 enums, 2 classes, 1 slot)"

### Custom Preset Management
User-managed presets replacing hard-coded ones:
- Save Preset button
- Prompts user for preset name
- Saves current panel configuration (sections + dialogs) to localStorage
- Display saved presets in header
- Remove icon for each preset

### Advanced Overview
Multiple view modes and analytics:
- Tree view (current), Network view, Matrix view (class-enum usage)
- Mini-map showing current focus area in context of full model
- Statistics dashboard (relationship counts, distribution charts)

---

## Technical Notes

### Data Loading
- Schema source: `bdchm.yaml` ‚Üí `bdchm.metadata.json` (generated by Python/LinkML tools)
- Variables: `variable-specs-S1.tsv` (downloaded from Google Sheets)
- Update command: `npm run download-data`

### MeasurementObservation Challenge
103 variables map to a single class (68% of all variables). Requires:
- Pagination or virtualization (future)
- Grouping/filtering within class (‚úì implemented - collapsible by class)
- Consider sub-categorization by measurement type

### Why Not Force-Directed Graphs?
- **Class inheritance** is a tree ‚Üí use tree layout ‚úì
- **Variables‚ÜíClasses** is bipartite ‚Üí use bipartite layout or tables ‚úì
- **Full relationship graph** would be chaotic ‚Üí filter by relationship type first

Force-directed layouts are useful for:
- Exploring k-hop neighborhoods (after filtering)
- Visualizing class associations (not inheritance)
- Showing clusters of related enums/classes

But default view should be structured (tree/table), not force-directed chaos.

### Performance Optimizations (Future)
When working with larger models or slower devices:
- **Virtualize long lists**: MeasurementObservation has 103 variables; consider react-window or react-virtual
- **Viewport culling for links**: Only render SVG links for visible elements
- **Animation library**: Consider react-spring for smoother transitions (current CSS transitions work fine)

---
## Architectural Decision Points

### DECISION: Move renderItems to Section.tsx with Generic Tree Types

**Status**: ‚úÖ Decided, implementation in progress (see Phase 3h in PROGRESS.md)

**Problem**: renderItems() puts view code in model classes. Collections know their structure (tree vs flat vs grouped), but rendering should be in Section.tsx.

**Solution**:
1. ‚úÖ Create generic Tree<T> types to replace ClassNode-specific hierarchy
2. üîÑ Collections implement getRenderableItems() returning RenderableItem[]
   - ‚úÖ EnumCollection and SlotCollection done
   - ‚è≥ ClassCollection and VariableCollection pending
3. ‚è≥ RenderableItem has structure info (level, hasChildren, isExpanded) plus isClickable flag
4. ‚è≥ Section.tsx renders RenderableItems generically
5. ‚è≥ Variable group headers use actual ClassElement (not null or special type)

**Benefits**:
- Collections define structure as data, not React rendering
- Section doesn't need type-specific conditionals
- Easy to add new element types
- Generic tree operations (flatten, search, traverse)

See temp.md "CURRENT WORK" section for detailed implementation status.

### OPEN QUESTION: Where Should Element Type Metadata Live?

**Status**: Deferred - keeping ElementRegistry.ts for now (working well)

**Current approach:**
- Separate `ElementRegistry.ts` file with:
  - `ELEMENT_TYPES` map: colors, labels, icons, pluralLabel per type
  - `RELATIONSHIP_TYPES` map: relationship metadata
  - Helper functions: `getAllElementTypeIds()`, `isValidElementType()`
- Element classes import from registry: `ELEMENT_TYPES[this.type]`

**Alternative approach:**
Put metadata directly in element classes as static properties:
```typescript
class ClassElement extends Element {
  static readonly typeId = 'class' as const;
  static readonly metadata = {
    icon: 'C',
    label: 'Class',
    pluralLabel: 'Classes',
    color: { name: 'blue', selectionBg: '...', ... }
  };

  readonly type = ClassElement.typeId;
  // ...
}
```

**Tradeoffs:**

**Option A: Keep separate registry (current)**
- ‚úÖ All metadata in one place, easy to see full type system
  - sg note: there are also types and interfaces in types.tx; should they move?
- ‚úÖ Can add new element types without touching existing files
- ‚úÖ Registry can have utility functions operating on all types
- ‚úÖ Clear separation: models focus on data, registry on metadata
- ‚ùå Extra indirection: `ELEMENT_TYPES[this.type]` instead of `this.metadata`
- ‚ùå Two places to update when adding element types

**Option B: Metadata in element classes**
- ‚úÖ Metadata lives with the class it describes (better cohesion)
- ‚úÖ Less indirection: `ClassElement.metadata` is direct
- ‚úÖ TypeScript can enforce metadata completeness per class
- ‚ùå Metadata scattered across multiple files
- ‚ùå Harder to see full type system at a glance
- ‚ùå Registry functions would need to iterate all classes

**Hybrid option C: Classes define metadata, registry aggregates**
```typescript
// ClassElement.ts
class ClassElement extends Element {
  static readonly metadata = { ... };
}

// ElementRegistry.ts (generated/aggregated)
export const ELEMENT_TYPES = {
  class: ClassElement.metadata,
  enum: EnumElement.metadata,
  slot: SlotElement.metadata,
  variable: VariableElement.metadata
} as const;
```
- ‚úÖ Metadata defined with classes (cohesion)
- ‚úÖ Registry provides convenient lookup
- ‚ùå More complex, potential for sync issues

**User's question:** "Is there any reason not to combine stuff from ElementRegistry into model classes? I'm not sure where to put it"

**Considerations:**
- If we move renderItems out of model classes (see selectedElement question), models become more data-focused ‚Üí suggests keeping metadata separate
- If element classes handle their own rendering, having metadata there makes sense
- Current registry is only ~200 lines and provides nice overview of type system
- Would split registry into 4+ files (one per element type) if moved into classes

**Recommendation TBD** - Depends on outcome of renderItems/selectedElement discussion. If models stay focused on data (no view code), keep registry separate. If models handle their own display, move metadata into classes.

---

## Implementation Notes & Lessons Learned

### LinkML Metadata Structure Gotchas

**Bug fix reference**: DetailView.tsx originally looked for `propDef.type` (JSON Schema convention) but LinkML metadata uses `propDef.range` for type information.

**Attribute structure in `bdchm.metadata.json`**:
```json
{
  "classes": {
    "Specimen": {
      "attributes": {
        "specimen_type": {
          "range": "SpecimenTypeEnum",
          "description": "...",
          "multivalued": false,
          "required": false
        }
      }
    }
  }
}
```

Key fields:
- `range`: The type (primitive, enum name, or class name)
- `multivalued`: Boolean indicating array vs single value
- `required`: Boolean for required attributes
- `description`: Free text

### Structural vs Semantic Categorization

**Current approach** (structural - safe from schema changes):
- Categorize by `range` value:
  - **Primitive**: Known set (`string`, `integer`, `float`, etc.)
  - **Enum**: Range ends with `Enum`
  - **Class**: Everything else
- Filter/toggle by entity type: class, enum, slot, variable

**DO NOT hard-code semantic categories** like "containment" vs "association" vs "activity" - these could break with schema updates.

### REMINDER: Semantic Insights for Future Use

The following **semantic relationship patterns** were identified during analysis and could be valuable for:
- User-facing documentation/tooltips
- Search result grouping
- Suggested exploration paths
- AI-assisted query answering

**Semantic patterns identified**:

1. **Containment/Part-of**: `parent_specimen`, `parent_container`, `part_of`
2. **Association**: `associated_participant`, `source_participant`, `performed_by`
3. **Activity/Process**: `creation_activity`, `processing_activity`, `storage_activity`
4. **Measurement**: `value_quantity`, `range_low`, `range_high`, `quantity_measure`
5. **Provenance**: `*_provenance`, `derived_from`
6. **Organization/Study**: `member_of_research_study`, `originating_site`

**Potential future features using semantic patterns**:
- "Show specimen workflow" - follow activity relationships
- "Show participant data" - trace associated_participant links
- "Explain this class" - generate natural language description using relationship semantics
- Smart search: "find containment relationships" could match `parent_*` and `part_of` patterns

**Implementation approach when ready**:
- Extract patterns from attribute names (regex/keyword matching)
- Make patterns configurable (JSON/YAML file of patterns)
- Use for suggestions/enhancements, not core functionality
- Keep structural navigation as primary interface
