// Schema type definitions - Transformed types for Element constructors and data structures
// These are NOT DTOs - they are camelCase transformed data ready for use in the app

import Graph from 'graphology';
// Import and re-export SlotDefinition from import_types (it's part of the DTO structure but used everywhere)
import type { SlotDefinition } from '../import_types';
export type { SlotDefinition };

// ============================================================================
// Transformed Types - Used by Element constructors and data structures
// ============================================================================

/**
 * Slot data for SlotElement constructor
 * Transformed from SlotDTO with camelCase
 */
export interface SlotData {
  range?: string;
  description?: string;
  slotUri?: string;  // transformed from slot_uri
  identifier?: boolean;
  required?: boolean;
  multivalued?: boolean;
}

/**
 * Enum data for EnumElement constructor
 * Transformed from EnumDTO
 */
export interface EnumData {
  description?: string;
  permissibleValues?: Record<string, {  // transformed from permissible_values
    description?: string;
    meaning?: string;
  }>;
}

/**
 * Type data for TypeElement constructor
 * Transformed from TypeDTO with camelCase
 */
export interface TypeData {
  uri: string;
  base: string;
  repr?: string;
  description?: string;
  notes?: string;  // Normalized to string (join array if needed)
  exactMappings?: string[];  // transformed from exact_mappings
  closeMappings?: string[];  // transformed from close_mappings
  broadMappings?: string[];  // transformed from broad_mappings
  conformsTo?: string;  // transformed from conforms_to
}

/**
 * Class data for ClassElement constructor
 * From bdchm.processed.json (generated by transform_schema.py)
 * All slots, slot_usage, and attributes are merged into attributes field
 */
export interface ClassData {
  name: string;
  description: string;
  parent?: string;  // Normalized from is_a
  abstract: boolean;
  attributes: Record<string, SlotDefinition>;  // Pre-computed with slotId and inherited_from
  class_url?: string;  // Expanded from class_uri using prefixes
}

/**
 * Variable specification data for VariableElement constructor (transformed)
 */
export interface VariableSpec {
  maps_to: string;  // Class ID that this variable maps to (no transformation needed - same as DTO)
  variableLabel: string;
  dataType: string;
  ucumUnit: string;
  curie: string;
  variableDescription: string;
}

/**
 * Complete transformed schema data ready for Element constructors
 */
export interface SchemaData {
  classes: ClassData[];
  enums: Map<string, EnumData>;
  slots: Map<string, SlotData>;
  types: Map<string, TypeData>;  // LinkML types from types.yaml
  variables: VariableSpec[];
}

/**
 * Enum value (used in processing enum metadata)
 */
export interface EnumValue {
  key: string;
  description?: string;
}

/**
 * Field mapping specification for transforming DTOs to Data types.
 * Maps DTO field names (keys) to Data field names (values).
 * If value is undefined, the field is copied as-is.
 */
export interface FieldMapping {
  [dtoField: string]: string | undefined;
}




// ============================================================================
// Node Types
// ============================================================================

/**
 * Node types in the schema graph
 */
type NodeType = 'class' | 'enum' | 'slot' | 'type' | 'variable';

/**
 * Base attributes stored on all nodes
 * These are stored directly in graphology for efficient queries
 */
interface BaseNodeAttributes {
  type: NodeType;
  name: string;  // Display name (same as node ID for most nodes)
}

/**
 * Class node attributes
 * Minimal data - ClassElement instance has full details
 */
export interface ClassNodeAttributes extends BaseNodeAttributes {
  type: 'class';
  // Future: Add queryable properties if needed (e.g., isAbstract: boolean)
}

/**
 * Enum node attributes
 */
export interface EnumNodeAttributes extends BaseNodeAttributes {
  type: 'enum';
}

/**
 * Slot node attributes
 * Slots exist as definitions that can be referenced by multiple SlotEdges
 */
export interface SlotNodeAttributes extends BaseNodeAttributes {
  type: 'slot';
}

/**
 * Type node attributes
 */
export interface TypeNodeAttributes extends BaseNodeAttributes {
  type: 'type';
}

/**
 * Variable node attributes
 */
export interface VariableNodeAttributes extends BaseNodeAttributes {
  type: 'variable';
}

/**
 * Union of all node attributes
 */
export type NodeAttributes =
    | ClassNodeAttributes
    | EnumNodeAttributes
    | SlotNodeAttributes
    | TypeNodeAttributes
    | VariableNodeAttributes;

// ============================================================================
// Edge Types
// ============================================================================

/**
 * Edge type constants - Use these instead of string literals
 */
export const EDGE_TYPES = {
  INHERITANCE: 'inheritance',
  SLOT: 'slot',
  MAPS_TO: 'maps_to',
} as const;

/**
 * Edge types in the schema graph
 */
export type EdgeType = typeof EDGE_TYPES[keyof typeof EDGE_TYPES];

/**
 * Base attributes stored on all edges
 */
interface BaseEdgeAttributes {
  type: EdgeType;
}

/**
 * Inheritance edge: Class → Parent Class
 * Represents is_a/inherits_from relationships
 */
export interface InheritanceEdgeAttributes extends BaseEdgeAttributes {
  type: 'inheritance';
}

/**
 * Slot edge: Class → Range (Class | Enum | Type)
 * Represents class attributes/slots with their ranges
 *
 * KEY INSIGHT: There are MORE slot edges than slot definitions.
 * - Same slot definition can be used by multiple classes
 * - Each class-range pair gets its own edge
 * - Edge references the slot definition and may have overrides
 */
export interface SlotEdgeAttributes extends BaseEdgeAttributes {
  type: 'slot';
  slotName: string;           // Name of the slot (e.g., "specimen_type")
  slotDefId: string;          // ID of the SlotElement definition node
  required: boolean;          // Is this slot required?
  multivalued: boolean;       // Is this slot multivalued?
  inheritedFrom?: string;     // If inherited, which ancestor defined it?
  // Future: Add more slot_usage override properties as needed
}

/**
 * MapsTo edge: Variable → Class
 * Represents variable mappings to schema classes
 */
export interface MapsToEdgeAttributes extends BaseEdgeAttributes {
  type: 'maps_to';
}

/**
 * Union of all edge attributes
 */
export type EdgeAttributes =
    | InheritanceEdgeAttributes
    | SlotEdgeAttributes
    | MapsToEdgeAttributes;

// ============================================================================
// Graph Type
// ============================================================================

/**
 * Typed graphology graph for the schema
 * This provides type safety for node/edge attributes
 */
export type SchemaGraph = Graph<NodeAttributes, EdgeAttributes>;

