// Schema type definitions - Transformed types for Element constructors and data structures
// These are NOT DTOs - they are camelCase transformed data ready for use in the app

import Graph from 'graphology';
// Import and re-export SlotDefinition from import_types (it's part of the DTO structure but used everywhere)
import type {SlotDefinition} from '../import_types';

export type { SlotDefinition };

// ============================================================================
// Transformed Types - Used by Element constructors and data structures
// ============================================================================

/**
 * Slot data for SlotElement constructor
 * Transformed from SlotDTO with camelCase
 */
export interface SlotData {
  range?: string;
  description?: string;
  slotUri?: string;  // transformed from slot_uri
  identifier?: boolean;
  required?: boolean;
  multivalued?: boolean;
}

/**
 * Enum data for EnumElement constructor
 * Transformed from EnumDTO
 */
export interface EnumData {
  description?: string;
  permissibleValues?: Record<string, {  // transformed from permissible_values
    description?: string;
    meaning?: string;
  }>;
}

/**
 * Type data for TypeElement constructor
 * Transformed from TypeDTO with camelCase
 */
export interface TypeData {
  uri: string;
  base: string;
  repr?: string;
  description?: string;
  notes?: string;  // Normalized to string (join array if needed)
  exactMappings?: string[];  // transformed from exact_mappings
  closeMappings?: string[];  // transformed from close_mappings
  broadMappings?: string[];  // transformed from broad_mappings
  conformsTo?: string;  // transformed from conforms_to
}

/**
 * Class data for ClassElement constructor
 * From bdchm.processed.json (generated by transform_schema.py)
 * All slots, slot_usage, and attributes are merged into attributes field
 */
export interface ClassData {
  name: string;
  description: string;
  parent?: string;  // Normalized from is_a
  abstract: boolean;
  attributes: Record<string, SlotDefinition>;  // Pre-computed with slotId and inherited_from
  class_url?: string;  // Expanded from class_uri using prefixes
}

/**
 * Variable specification data for VariableElement constructor (transformed)
 */
export interface VariableSpec {
  maps_to: string;  // Class ID that this variable maps to (no transformation needed - same as DTO)
  variableLabel: string;
  dataType: string;
  ucumUnit: string;
  curie: string;
  variableDescription: string;
}

/**
 * Complete transformed schema data ready for Element constructors
 */
export interface SchemaData {
  classes: ClassData[];
  enums: Map<string, EnumData>;
  slots: Map<string, SlotData>;
  types: Map<string, TypeData>;  // LinkML types from types.yaml
  variables: VariableSpec[];
}

/**
 * Enum value (used in processing enum metadata)
 */
export interface EnumValue {
  key: string;
  description?: string;
}

/**
 * Field mapping specification for transforming DTOs to Data types.
 * Maps DTO field names (keys) to Data field names (values).
 * If value is undefined, the field is copied as-is.
 */
export interface FieldMapping {
  [dtoField: string]: string | undefined;
}




// ============================================================================
// Node Types
// ============================================================================

/**
 * Node types in the schema graph
 */
type NodeType = 'class' | 'enum' | 'slot' | 'type' | 'variable';

/**
 * Base attributes stored on all nodes
 * These are stored directly in graphology for efficient queries
 */
interface BaseNodeAttributes {
  type: NodeType;
  name: string;  // Display name (same as node ID for most nodes)
}

/**
 * Class node attributes
 * Minimal data - ClassElement instance has full details
 */
export interface ClassNodeAttributes extends BaseNodeAttributes {
  type: 'class';
  // Future: Add queryable properties if needed (e.g., isAbstract: boolean)
}

/**
 * Enum node attributes
 */
export interface EnumNodeAttributes extends BaseNodeAttributes {
  type: 'enum';
}

/**
 * Slot node attributes
 * Slots exist as definitions that can be referenced by multiple SlotEdges
 */
export interface SlotNodeAttributes extends BaseNodeAttributes {
  type: 'slot';
}

/**
 * Type node attributes
 */
export interface TypeNodeAttributes extends BaseNodeAttributes {
  type: 'type';
}

/**
 * Variable node attributes
 */
export interface VariableNodeAttributes extends BaseNodeAttributes {
  type: 'variable';
}

/**
 * Union of all node attributes
 */
export type NodeAttributes =
    | ClassNodeAttributes
    | EnumNodeAttributes
    | SlotNodeAttributes
    | TypeNodeAttributes
    | VariableNodeAttributes;

// ============================================================================
// Edge Types
// ============================================================================

/**
 * Edge type constants - Use these instead of string literals
 *
 * Three slot-related edge types support both 2-panel and 3-panel modes:
 * - CLASS_RANGE: class→range (2-panel mode, direct link)
 * - CLASS_SLOT: class→slot (3-panel mode, first hop)
 * - SLOT_RANGE: slot→range (3-panel mode, second hop)
 */
export const EDGE_TYPES = {
  INHERITANCE: 'inheritance',
  CLASS_RANGE: 'class_to_range',  // class→range (2-panel mode)
  CLASS_SLOT: 'class_to_slot',    // class→slot (3-panel mode)
  SLOT_RANGE: 'slot_to_range',    // slot→range (3-panel mode)
  MAPS_TO: 'maps_to',
} as const;

/**
 * Get edge types to render based on panel configuration
 */
export function getEdgeTypesForLinks(middlePanelShown: boolean): EdgeType[] {
  if (middlePanelShown) {
    return [EDGE_TYPES.CLASS_SLOT, EDGE_TYPES.SLOT_RANGE, EDGE_TYPES.MAPS_TO];
  } else {
    return [EDGE_TYPES.CLASS_RANGE, EDGE_TYPES.MAPS_TO];
  }
}

/**
 * Edge types in the schema graph
 */
export type EdgeType = typeof EDGE_TYPES[keyof typeof EDGE_TYPES];

/**
 * Base attributes stored on all edges
 */
interface BaseEdgeAttributes {
  type: EdgeType;
}

/**
 * Inheritance edge: Class → Parent Class
 * Represents is_a/inherits_from relationships
 */
export interface InheritanceEdgeAttributes extends BaseEdgeAttributes {
  type: 'inheritance';
}

/**
 * CLASS_RANGE edge: Class → Range (Class | Enum | Type)
 * Direct class-to-range link for 2-panel mode
 */
export interface ClassRangeEdgeAttributes extends BaseEdgeAttributes {
  type: 'class_to_range';
  slotName: string;           // Name of the slot (e.g., "specimen_type")
  slotDefId: string;          // ID of the SlotElement definition node
  required: boolean;
  multivalued: boolean;
  inheritedFrom?: string;
}

/**
 * CLASS_SLOT edge: Class → Slot
 * First hop in 3-panel mode (class to slot in middle panel)
 */
export interface ClassSlotEdgeAttributes extends BaseEdgeAttributes {
  type: 'class_to_slot';
  slotName: string;
  required: boolean;
  multivalued: boolean;
  inheritedFrom?: string;
}

/**
 * SLOT_RANGE edge: Slot → Range (Class | Enum | Type)
 * Second hop in 3-panel mode (slot to range in right panel)
 */
export interface SlotRangeEdgeAttributes extends BaseEdgeAttributes {
  type: 'slot_to_range';
}

/**
 * MapsTo edge: Variable → Class
 * Represents variable mappings to schema classes
 */
export interface MapsToEdgeAttributes extends BaseEdgeAttributes {
  type: 'maps_to';
}

/**
 * Union of all edge attributes
 */
export type EdgeAttributes =
    | InheritanceEdgeAttributes
    | ClassRangeEdgeAttributes
    | ClassSlotEdgeAttributes
    | SlotRangeEdgeAttributes
    | MapsToEdgeAttributes;

/** Alias for backwards compatibility */
export type SlotEdgeAttributes = ClassRangeEdgeAttributes;

// ============================================================================
// Graph Type
// ============================================================================

/**
 * Typed graphology graph for the schema
 * This provides type safety for node/edge attributes
 */
export type SchemaGraph = Graph<NodeAttributes, EdgeAttributes>;

/**
 * ItemInfo - Complete item metadata including panel positioning
 * Used for rendering items in UI with proper context
 */
export interface ItemInfo {
  id: string;
  displayName: string;
  type: string;  // Element type ID: 'class', 'enum', 'slot', 'type', 'variable'
  typeDisplayName: string;  // User-facing label: "Class", "Enumeration", "Slot", "Type", "Variable"
  color: string;  // Tailwind color classes for styling
  // panelPosition: 'left' | 'right';
  // panelId: 'left' | 'middle' | 'right'; // these should be dom ids on the panels
}

/**
 * EdgeInfo - Complete edge representation with both source and target
 * Used for rendering relationships between items
 */
export interface EdgeInfo {
  edgeType: EdgeType;
  sourceItem: ItemInfo;
  targetItem: ItemInfo;
  label?: string;       // For slot edges: slot/attribute name; for maps_to: "mapped_to"
  inheritedFrom?: string; // For slot edges only: ancestor name that defined this slot
}

/**
 * RelationshipData - Unified relationship structure using edges
 * Replaces old type-dependent relationship structure with generic edge-based model
 */
export interface RelationshipData {
  thisItem: ItemInfo;
  outgoing: EdgeInfo[];
  incoming: EdgeInfo[];
}